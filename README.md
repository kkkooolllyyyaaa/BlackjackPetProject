## **Блэкджек**

Требуется разработать программу, реализующую игру в блэкджек с использованием порождающих паттернов проектирования.

Требования:

- Использовать enum классы где нужно
- Использовать interface'ы где нужно
- Использовать abstract классы где нужно
- Игроки `Player` могут присоединяться к игре `BlackjackGame`, выбирать размер ставки и играть в игру
- Карты `Card` раздает отдельная сущность `Dealer`, для этого он принимает колоду `Deck`, перемешивает её и возвращает по одному
- Нужно реализовать несколько реализаций перемешивания `ShuffleAlgorithm`: "без перемешивания", "рандомную", "perfect shuffle"
- Должны быть реализованы правила блэкджека: игроки получают две карты, дилер получает одну карту; игроки могут брать дополнительные карты, пока не наберут более 21 очка; дилер должен брать карты, пока не наберет 17 очков или больше; при сумме очков более 21 игрок проигрывает, при сумме очков более 17, но меньше 21, дилер останавливается и происходит сравнение очков.
- Должна быть реализована логика ставок: при выигрыше игрок получает в два раза больше своей ставки, при проигрыше ставка снимается
- При ничьих по очкам ставка игрока возвращается
- При наборе 21 очка игроком он автоматически выигрывает, вне зависимости от количества очков дилера
- Для сбора ставок и вознаграждений реализовать сущность `Bank`, который оперирует сущностью `BankAccount`
- Постарайтесь чтобы абстракции не утекали, а связт были логичными. Например:
  - `Bank` оперирует `BankAccount`, а не `Player`, но при этом у каждого игрока есть счет в банке
  - `BlackjackGame` ничего не знает про банк, он знает кто играет и кто выиграл. Поэтому должен быть верхний класс `BlackjackCasino`, который порождает `BlackjackGame` для игроков, и раздает выигрыш с помощью `Bank`
- По необходимости используйте List (ArrayList, LinkedList), Map (HashMap, LinkedHashMap), Set (HashSet)


Требования к проверке:

1. Необходимо реализовать тесты, чтобы убедиться в корректности работы программы.
2. Код должен быть написан с использованием принципов объектно-ориентированного программирования, в том числе SOLID, DRY, KISS
3. Для реализации могут использоваться следующие паттерны:
- [Адаптер](https://ru.wikipedia.org/wiki/%D0%90%D0%B4%D0%B0%D0%BF%D1%82%D0%B5%D1%80_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)) (Adapter)
- [Мост](https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D1%81%D1%82_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)) (Bridge)
- [Декоратор](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BA%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)) (Decorator)
- [Фасад](https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D1%81%D0%B0%D0%B4_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)) (Facade)
- [Заместитель](https://ru.wikipedia.org/wiki/Proxy_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)) (Proxy)
